= TypeGenerator JUnit Extension Implementation Plan

This document outlines the steps required to implement a JUnit 5 extension/annotation for using TypeGenerator directly within parameterized tests.

== Overview

The goal is to create a JUnit 5 extension that allows developers to use TypeGenerator instances directly in parameterized tests. This will enable more efficient test data generation and better integration with the existing TypeGenerator framework.

We will implement two main approaches:
1. Direct class-based configuration: Specify a TypeGenerator class to be instantiated
2. Method binding: Define a method that returns a concrete TypeGenerator instance
3. Additional enhancements for better usability

== Implementation Steps

[cols="1,3,1"]
|===
|Step |Description |Status

|1 |Update Maven Dependencies |✅
|1.1 |Change `junit-jupiter-params` scope from `test` to `compile` |✅

|2 |Create TypeGeneratorSource Annotation |✅
|2.1 |Define annotation with class-based configuration parameter |✅
|2.2 |Add support for specifying number of instances to generate |✅
|2.3 |Add support for seed configuration |✅

|3 |Create TypeGeneratorArgumentsProvider |✅
|3.1 |Implement ArgumentsProvider interface |✅
|3.2 |Implement AnnotationConsumer for TypeGeneratorSource |✅
|3.3 |Implement instantiation logic for TypeGenerator classes |✅
|3.4 |Add seed management integration with GeneratorControllerExtension |✅

|4 |Create TypeGeneratorMethodSource Annotation |✅
|4.1 |Define annotation with method reference parameter |✅
|4.2 |Add support for specifying number of instances to generate |✅

|5 |Create TypeGeneratorMethodArgumentsProvider |✅
|5.1 |Implement ArgumentsProvider interface |✅
|5.2 |Implement AnnotationConsumer for TypeGeneratorMethodSource |✅
|5.3 |Implement method invocation logic to get TypeGenerator instances |✅
|5.4 |Add support for static and instance methods |✅

|6 |Create TypeGeneratorFactorySource Annotation (Optional Enhancement) |⬜
|6.1 |Define annotation with factory class parameter |⬜
|6.2 |Add support for factory method name |⬜
|6.3 |Add support for factory method parameters |⬜

|7 |Create TypeGeneratorFactoryArgumentsProvider (Optional Enhancement) |⬜
|7.1 |Implement ArgumentsProvider interface |⬜
|7.2 |Implement AnnotationConsumer for TypeGeneratorFactorySource |⬜
|7.3 |Implement factory method invocation logic |⬜

|8 |Create CompositeTypeGeneratorSource Annotation (Optional Enhancement) |⬜
|8.1 |Define annotation for combining multiple TypeGenerators |⬜
|8.2 |Add support for cartesian product generation |⬜

|9 |Update Documentation |✅
|9.1 |Add JavaDoc for all new classes and methods |✅
|9.2 |Update README.adoc with usage examples |✅
|9.3 |Create specific documentation for the new extensions |✅

|10 |Create Unit Tests |✅
|10.1 |Test TypeGeneratorSource with various TypeGenerator implementations |✅
|10.2 |Test TypeGeneratorMethodSource with various method configurations |✅
|10.3 |Test optional enhancements if implemented |✅
|10.4 |Test edge cases and error conditions |✅

|11 |Create Integration Tests |✅
|11.1 |Create sample test cases demonstrating real-world usage |✅
|11.2 |Test compatibility with existing JUnit 5 features |✅
|11.3 |Test performance with large data sets |✅

|12 |Final Review and Refactoring |✅
|12.1 |Code review for adherence to project standards |✅
|12.2 |Performance optimization if needed |✅
|12.3 |Final documentation review |✅
|===

== Detailed Design Notes

=== TypeGeneratorSource Annotation

[source,java]
----
@Target({ ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ArgumentsSource(TypeGeneratorArgumentsProvider.class)
public @interface TypeGeneratorSource {
    
    // The TypeGenerator class to use
    Class<? extends TypedGenerator<?>> value();
    
    // Number of instances to generate (default: 1)
    int count() default 1;
    
    // Optional seed for reproducible tests
    long seed() default -1L;
}
----

=== TypeGeneratorMethodSource Annotation

[source,java]
----
@Target({ ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ArgumentsSource(TypeGeneratorMethodArgumentsProvider.class)
public @interface TypeGeneratorMethodSource {
    
    // The method name to invoke to get the TypeGenerator
    String value();
    
    // Number of instances to generate (default: 1)
    int count() default 1;
}
----

=== Usage Examples

==== Class-based Configuration

[source,java]
----
@EnableGeneratorController
class StringGeneratorTest {

    @ParameterizedTest
    @TypeGeneratorSource(NonBlankStringGenerator.class)
    void testWithGeneratedStrings(String value) {
        assertNotNull(value);
        assertFalse(value.isBlank());
    }
    
    @ParameterizedTest
    @TypeGeneratorSource(value = IntegerGenerator.class, count = 5)
    void testWithMultipleIntegers(Integer value) {
        assertNotNull(value);
    }
}
----

==== Method-based Configuration

[source,java]
----
@EnableGeneratorController
class CustomGeneratorTest {

    @ParameterizedTest
    @TypeGeneratorMethodSource("createStringGenerator")
    void testWithCustomGenerator(String value) {
        assertNotNull(value);
    }
    
    static TypedGenerator<String> createStringGenerator() {
        return Generators.strings(5, 10);
    }
}
----

== Additional Considerations

1. *Seed Management*: Ensure proper integration with the existing seed management in GeneratorControllerExtension.

2. *Error Handling*: Provide clear error messages for common issues like:
   - TypeGenerator instantiation failures
   - Method not found or inaccessible
   - Type mismatches between generator and test method parameter

3. *Performance*: Consider caching TypeGenerator instances when appropriate to avoid repeated instantiation.

4. *Extensibility*: Design the implementation to allow for future enhancements and customizations.
